<?php
/*
 * This file is part of the sfDoctrinePlugin package.
 * (c) 2006-2007 Olivier Verdier <Olivier.Verdier@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Config handler for doctrine
 *
 * @package    sfDoctrinePlugin
 * @author     Amadeus
 * @author     Olivier Verdier <Olivier.Verdier@gmail.com>
 * @author     Dan Porter
 * @version    SVN: $Id: sfDoctrineConfigHandler.class.php 5275 2007-09-25 16:16:14Z hartym $
 */
class sfDoctrineConfigHandler extends sfYamlConfigHandler
{
  public function execute($configFiles)
  {
    // Parse yaml config files
    $configs = $this->parseYamls($configFiles);

    // Default config: all.attributes
    $default_config = array();
    if (isset ($configs['all']['attributes']) && is_array($configs['all']['attributes']))
    {
      $default_config = $configs['all']['attributes'];
      unset ($configs['all']['attributes']);
    }

    // Default config: all.listeners
    $default_listeners = array();
    if (isset ($configs['all']['global_listeners']) && is_array($configs['all']['global_listeners']))
    {
      $default_listeners = $configs['all']['global_listeners'];
      unset ($configs['all']['global_listeners']);
    }


    // Environment specific defaults: <env>.attributes
    $env = sfConfig::get('sf_environment');
    if (isset ($configs[$env]['attributes']) && is_array($configs[$env]['attributes']))
    {
      $default_config = sfToolKit::arrayDeepMerge($default_config, $configs[$env]['attributes']);
      unset ($configs[$env]['attributes']);
    }

    // Environment specific defaults: <env>.listeners
    if (isset ($configs[$env]['global_listeners']) && is_array($configs[$env]['global_listeners']))
    {
      $default_listeners = sfToolKit::arrayDeepMerge($default_listeners, $configs[$env]['global_listeners']);
      unset ($configs[$env]['global_listeners']);
    }


    // Connection specific configs
    $conn_configs = array();
    foreach ($configs as $env => $env_config)
    {
      foreach ($env_config as $conn => $conn_config)
      {
        $conn_configs[$conn] = sfToolkit::arrayDeepMerge($default_config, $conn_config);
      }
    }

    // Prepare default config data
    $data = array();
    foreach ($this->configToAttributes($default_config) as $key => $value)
    {
      $data[] = sprintf('$default_attributes["%s"] = %s;', $key, $this->attributeToPhp($value));
    }
    // Prepare default config listeners
    //$data[] = '$default_listeners = array();';
    foreach ($this->configToListeners($default_listeners) as $value)
    {
      $data[] = sprintf('$default_listeners[] = %s;', $this->attributeToPhp($value));
    }
    $data[] = '';

    // Prepare connection specific data
    foreach ($conn_configs as $conn_name => $conn_config)
    {
      foreach ($this->configToAttributes($conn_config) as $key => $value)
      {
        $data[] = sprintf('$attributes["%s"]["%s"] = %s;', $conn_name, $key, $this->attributeToPHP($value));
      }
      $data[] = '';
    }
    // TODO: the same as above for listeners

    // compile data
    $retval = sprintf("<?php\n" .
    "// auto-generated by sfDoctrineConfigHandler\n" .
    "// date: %s\n%s\n", date('Y-m-d H:i:s'), implode("\n", $data));

    return $retval;
  }

  protected function configToListeners($config)
  {
    $listeners = array();

    foreach($config as $value)
    {
      $listeners[] = array('php', "new $value()");
    }
    return $listeners;
  }

  protected function configToAttributes($config)
  {
    $attributes = array();
    foreach ($config as $key => $value)
    {
      $attr_key = 'ATTR_' . strtoupper($key);

      switch ($key)
      {
          // event listener (name of the listener class)
        case 'listener':
          $attributes[$attr_key] = array ('php', "new $value()");
          break;

        // fetch mode (immediate, batch, offset, lazy_offset)
        case 'fetchmode':
          $attributes[$attr_key] = array ('constant', 'FETCH_' . strtoupper($value));
          break;

          // locking (optimistic, pessimistic)
        case 'lockmode':
          $attributes[$attr_key] = array ('constant', 'LOCK_' . strtoupper($value));
          break;

          // export (none, tables, constraints, all)
          case 'export':
            $attributes[$attr_key] = array('constant', 'EXPORT_'.strtoupper($value));
            break;

          // accessors (none, get, set, both)
/*        case 'accessors':
          $attributes[$attr_key] = array ('constant', 'ACCESSOR_' . strtoupper($value));
          break;
*/
          // portability (none, fix_case, rtrim, delete_count, empty_to_null, fix_assoc_field_names, all)
        case 'portability':
          $attributes[$attr_key] = array ('constant', 'PORTABILITY_' . strtoupper($value));
          break;

        // the default will set the value as a string or a boolean (depending on the type returned by the yaml parser)
        default:
          $attributes[$attr_key] = $value;
      }
    }
    return $attributes;
  }

  protected function attributeToPhp($attr)
  {
    if (is_array($attr))
    {
      if ($attr[0] == 'constant')
      {
        $attr = 'Doctrine::' . $attr[1];
      }
      elseif ($attr[0] == 'php')
      {
        $attr = $attr[1];
      }
    }
    elseif (is_string($attr))
    {
      $attr = sprintf("'%s'", $attr);
    }
    else
    {
      $attr = var_export($attr, 1);
    }
    return $attr;
  }
}